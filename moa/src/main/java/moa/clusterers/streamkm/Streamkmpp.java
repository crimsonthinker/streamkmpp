package moa.clusterers.streamkm;

import com.github.javacliparser.FileOption;
import com.github.javacliparser.IntOption;
import com.github.javacliparser.StringOption;
import com.opencsv.*;
import com.yahoo.labs.samoa.instances.Instance;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.*;

import moa.cluster.Cluster;
import moa.cluster.Cluster;
import moa.cluster.Clustering;
import moa.clusterers.streamkm.BucketManager;
import moa.clusterers.streamkm.Point;
import moa.clusterers.streamkm.StreamKM;
import moa.core.AutoExpandVector;
import moa.core.TimingUtils;
import moa.streams.clustering.SimpleCSVStream;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartUtilities;
import org.jfree.chart.JFreeChart;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;

public class Streamkmpp extends StreamKM {
  SimpleCSVStream stream = new SimpleCSVStream();
  public static int numclus = 5;

  public Streamkmpp() {}

  public void run(
    String dataFile,
    String dataPath,
    String outputPath,
    String delimiter,
    int labelCol
  ) {
    String inputFile = dataPath + dataFile + ".txt";

    stream.csvFileOption =
      new FileOption(
        "csvFile",
        'f',
        "CSV file to load.",
        inputFile,
        "csv",
        false
      );
    stream.splitCharOption =
      new StringOption(
        "splitChar",
        's',
        "Input CSV split character",
        delimiter
      );

    this.lengthOption =
      new IntOption(
        "length",
        'l',
        "Length of the data stream (n).",
        10000,
        0,
        Integer.MAX_VALUE
      );
    this.sizeCoresetOption =
      new IntOption("sizeCoreset", 's', "Size of the coreset (m).", 5000);
    this.numClustersOption= new IntOption("numClusters", 'k', "Number of clusters to compute.", numclus);
    stream.prepareForUse();

    this.setModelContext(stream.getHeader());
    this.prepareForUse();

    boolean preciseCPUTiming = TimingUtils.enablePreciseTiming();
    long evaluateStartTime = TimingUtils.getNanoCPUTimeOfCurrentThread();
    int row = 0;
    while (stream.hasMoreInstances()) {
      Instance trainInst = stream.nextInstance().getData();
      // this depend on which dataset is currently test
      if (labelCol != 1000)
        trainInst.deleteAttributeAt(trainInst.numAttributes() + labelCol - 1);
      row++;
      this.trainOnInstanceImpl(trainInst);
    }
    double time = TimingUtils.nanoTimeToSeconds(
      TimingUtils.getNanoCPUTimeOfCurrentThread() - evaluateStartTime
    );
    System.out.println("Processed StreamKM++ in " + time + " seconds.");

    Clustering result = this.getClusteringResult();
    AutoExpandVector<Cluster> clusters = result.getClustering();

    long evaluatePostProcessStartTime = TimingUtils.getNanoCPUTimeOfCurrentThread();

    List<Double> firstPoint = readDataFirstLine(inputFile, delimiter.charAt(0));
    int pointDimension = firstPoint.size();
    if (labelCol != 1000)
      pointDimension = pointDimension + labelCol;

    // check if the centroid generated by streamkm match the correct dimension of input data
    List<List<Double>> centroidList = new ArrayList<List<Double>>();
    int clusterIndex = 0;
    while (clusterIndex < clusters.size()) {
      double[] fakeCentroid = clusters.get(clusterIndex).getCenter();
      int miniIndex = 0;
      List<Double> realCentroid = new ArrayList<Double>();

      while (miniIndex < pointDimension) {
        realCentroid.add(fakeCentroid[miniIndex]);
        miniIndex++;
      }

      centroidList.add(realCentroid);
      clusterIndex++;
    }
    this.postProcessData(
      inputFile,
      delimiter.charAt(0),
      dataFile,
      outputPath,
      1000,
      clusters,
      centroidList
    );

    double time2 = TimingUtils.nanoTimeToSeconds(
      TimingUtils.getNanoCPUTimeOfCurrentThread() - evaluatePostProcessStartTime
    );
    System.out.println("Post Processed in " + time2 + " seconds.");
    writeStatistics(outputPath, dataFile, time + time2);
  }

  protected static void writeStatistics(String path, String dataFile, double time) {
    try {
      FileWriter myWriter = new FileWriter(path + dataFile + "_stat.txt", true);
      myWriter.write("\n########################################## RESULT STAT ##########################################\n");
      myWriter.write("Dataset name: " + dataFile + "\n");
      myWriter.write("Number of cluster: " + numclus + "\n");
      double mb = 1024.0 * 1024.0;
      Runtime runtime = Runtime.getRuntime();
      myWriter.write("** Used Memory:  " + (runtime.totalMemory() - runtime.freeMemory()) / mb + " MB\n");
      myWriter.write("** Free Memory:  " + runtime.freeMemory() / mb + " MB\n");
      myWriter.write("** Total Memory: " + runtime.totalMemory() / mb + " MB\n");
      myWriter.write("** Max Memory:   " + runtime.maxMemory() / mb + " MB\n");
      myWriter.write("Duration: " + time + "s\n");
      myWriter.write("#################################################################################################\n");

      myWriter.close();
    } catch (IOException e) {
      System.out.println("An error occurred.");
      e.printStackTrace();
    }
  }

  protected static boolean createFile(String path) {
    try {
      File myObj = new File(path);
      if (myObj.exists()) myObj.delete();
      return myObj.createNewFile();
    } catch (IOException e) {
      System.out.println("An error occurred.");
      e.printStackTrace();
    }

    return false;
  }

  // Java code to illustrate reading a
  // CSV file line by line
  protected static List<Double> readDataFirstLine(String file, char delimiter) {
    try {
      // Create an object of file reader
      // class with CSV file as a parameter.and
      FileReader filereader = new FileReader(file);

      // create csvReader object passing
      // file reader as a parameter
      CSVReader csvReader = new CSVReader(filereader, delimiter, '"', 1);
      String[] nextRecord;
      List<Double> pointList = new ArrayList<Double>();

      // we are going to read data line by line
      if ((nextRecord = csvReader.readNext()) != null) {
        for (String cell : nextRecord) {
          pointList.add(Double.parseDouble(cell));
        }
      }
      System.out.println("Read fist line CSV done.");
      return pointList;
    } catch (Exception e) {
      e.printStackTrace();
    }

    return new ArrayList<Double>();
  }

  // Java code to illustrate reading a
  // CSV file line by line
  protected void postProcessData(
    String file,
    char delimiter,
    String dataFile,
    String outputPath,
    Integer bucketSize,
    AutoExpandVector<Cluster> clusters,
    List<List<Double>> centroidList
  ) {
    try {
      Point[] coreset = this.manager.getCoresetFromManager(this.dimension);
      // Create an object of file reader
      // class with CSV file as a parameter.
//      FileReader filereader = new FileReader(file);
//
//      // create csvReader object passing
//      // file reader as a parameter
//      CSVReader csvReader = new CSVReader(filereader, delimiter, '"', 1);
//      String[] nextRecord;
      List<List<Double>> pointList = new ArrayList<List<Double>>();
      String dataOutputFile = outputPath + dataFile + "_streamkmpp.txt";
      String imageOutputFile = dataFile + "_streamkmpp.jpg";
      int row = 1;

      // we are going to read data line by line
      if (createFile(dataOutputFile)) {
        for (; row <= coreset.length; row++) {
          Double[] coord = Arrays.stream(coreset[row-1].coordinates).boxed().toArray(Double[]::new);
          Double[] newCoord = new Double[coord.length-1];
          System.arraycopy(coord, 0, newCoord, 0, coord.length - 1);

          List<Double> point = Arrays.asList(newCoord);
          pointList.add(point);
          if (row % bucketSize == 0) {
            List<Integer> clusterIndexList = new ArrayList<Integer>();
            List<Double> clusterDistanceList = new ArrayList<Double>();
            for (int i = 0; i < bucketSize; i++) {
              double minDistanceToCentroid = Double.MAX_VALUE;
              int minClusterIndex = 0;
              int clusterIndex = 0;

              while (clusterIndex < clusters.size()) {
                double distanceToCentroid = Measure.euclideanDistance(
                  centroidList.get(clusterIndex),
                  pointList.get(i)
                );
                if (distanceToCentroid < minDistanceToCentroid) {
                  minClusterIndex = clusterIndex;
                  minDistanceToCentroid = distanceToCentroid;
                }
                clusterIndex++;
              }
              clusterIndexList.add(minClusterIndex);
              clusterDistanceList.add(minDistanceToCentroid);
            }
            writePointToFile(
              pointList,
              clusterIndexList,
              clusterDistanceList,
              dataOutputFile
            );
            pointList = new ArrayList<List<Double>>();
          }
//          row++;
        }
        if (row % bucketSize != 1) {
          List<Integer> clusterIndexList = new ArrayList<Integer>();
          List<Double> clusterDistanceList = new ArrayList<Double>();
          for (int i = 0; i < row % bucketSize - 1; i++) {
            double minDistanceToCentroid = Double.MAX_VALUE;
            int minClusterIndex = 0;
            int clusterIndex = 0;

            while (clusterIndex < clusters.size()) {
              double distanceToCentroid = Measure.euclideanDistance(
                centroidList.get(clusterIndex),
                pointList.get(i)
              );
              if (distanceToCentroid < minDistanceToCentroid) {
                minClusterIndex = clusterIndex;
                minDistanceToCentroid = distanceToCentroid;
              }
              clusterIndex++;
            }
            clusterIndexList.add(minClusterIndex);
            clusterDistanceList.add(minDistanceToCentroid);
          }
          writePointToFile(
            pointList,
            clusterIndexList,
            clusterDistanceList,
            dataOutputFile
          );
          pointList = new ArrayList<List<Double>>();
        }
      }
      System.out.println("Finish post process.");
    } catch (Exception e) {
      e.printStackTrace();
    }
  }

  protected static void writeFile(
    List<List<Double>> pointList,
    List<Integer> pointClusterIndexList,
    List<Double> distanceToCentroid,
    String path
  ) {
    if (createFile(path)) {
      try {
        FileWriter myWriter = new FileWriter(path);
        int pointListSize = pointList.size();
        int index = 0;

        while (index < pointListSize) {
          myWriter.write(
            pointList.get(index).toString() +
            "\t" +
            pointClusterIndexList.get(index).toString() +
            "\t" +
            distanceToCentroid.get(index).toString() +
            "\n"
          );
          index = index + 1;
        }
        myWriter.close();
        System.out.println("Successfully wrote to the file.");
      } catch (IOException e) {
        System.out.println("An error occurred.");
        e.printStackTrace();
      }
    }
  }

  protected static void writePointToFile(
    List<List<Double>> pointList,
    List<Integer> pointClusterIndexList,
    List<Double> distanceToCentroid,
    String path
  ) {
    try {
      FileWriter myWriter = new FileWriter(path, true);
      int pointListSize = pointList.size();
      int index = 0;

      while (index < pointListSize) {
        myWriter.write(
          pointList.get(index).toString() +
          "\t" +
          pointClusterIndexList.get(index).toString() +
          "\t" +
          distanceToCentroid.get(index).toString() +
          "\n"
        );
        index = index + 1;
      }
      myWriter.close();
    } catch (IOException e) {
      System.out.println("An error occurred.");
      e.printStackTrace();
    }
  }

  protected void saveScatterChart(
    String path,
    String plotName,
    List<List<Double>> pointList,
    List<Integer> pointClusterIndexList
  ) {
    if (createFile(path + plotName)) {
      try {
        if (pointList.get(0).size() >= 3) return;
        List<XYSeries> clusterSeries = new ArrayList<XYSeries>();
        Set<Integer> clusterIndexDistinct = new HashSet<Integer>(
          pointClusterIndexList
        );
        for (int t = 0; t < clusterIndexDistinct.size(); t++) clusterSeries.add(
          t,
          new XYSeries("Cluster " + t)
        );

        XYSeriesCollection plotData = new XYSeriesCollection();
        int s = 0;
        for (int index = 0; index < pointClusterIndexList.size(); index++) {
          int currentIndex = pointClusterIndexList.get(index);
          if (currentIndex != -2 && currentIndex != -1) clusterSeries
            .get(currentIndex)
            .add(pointList.get(index).get(0), pointList.get(index).get(1));
        }
        for (XYSeries x : clusterSeries) {
          plotData.addSeries(x);
        }

        JFreeChart scatterChart = ChartFactory.createScatterPlot(
          plotName,
          "X-Axis",
          "Y-Axis",
          plotData
        );
        ChartUtilities.saveChartAsJPEG(
          new File(path + plotName),
          scatterChart,
          1024,
          729
        );
        System.out.println("Successfully saved scatter chart");
      } catch (IOException e) {
        System.out.println("An error occurred.");
        e.printStackTrace();
      }
    }
  }

  public static void main(String[] args) throws IOException {
    Streamkmpp exp = new Streamkmpp();

    String fileName = "USCensus1990.data";
    String dataPath = "../coresetsparkstreaming/datasets/streamkm/";
    String outputPath = "../coresetsparkstreaming/result/process/streamkmpp/";
    exp.run(fileName, dataPath, outputPath, ",", -1);
  }
}
